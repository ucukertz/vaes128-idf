
#include "vaes128cbc.h"

static const char* TAG = "vaes128cbc";

/**
 * @brief Generate hex string from byte buffer
 * @param buf Byte buffer
 * @param n Number of bytes to be converted to hex string
 * @param out User-provided output buffer to store generated hexstring
 */
void vaes128cbc_byte2hstr(uint8_t* buf, size_t n, char* out)
{
  for (int i = 0; i < n; i++) {
    snprintf(out + (i*2), 3, "%02X", buf[i]);
  }
}

/**
 * @brief Generate byte stream from hex string
 * @param hstr Hex string
 * @param len Length of hstr to be converted to byte buffer
 * @param out User-provided output buffer to store generated bytes
 * @note Length of generated bytes is always half of length of input
 * @return 0 if input hexstring is valid
 */
vaes128cbc_err_t vaes128cbc_hstr2byte(char* hstr, size_t len, uint8_t* out)
{
  const char *pos = hstr;
  char *endptr;
  size_t count = 0;

  if (len == 0 || len % 2) {
    // Hexstr contains no data or hexstr has an odd length
    return VAES128CBC_ERR_INVALID_HEXSTR;
  }

  for (count = 0; count < len; count++) {
    char buf[5] = {'0', 'x', pos[0], pos[1], 0};
    out[count] = strtol(buf, &endptr, 0);
    pos += 2;

    if (endptr[0] != '\0') {
      // Non-hexadecimal character encountered - end conversion
      return VAES128CBC_OK;
    }
  }

  return VAES128CBC_OK;
}

static vaes128cbc_err_t _aes128cbc_enc(uint8_t* msg, size_t msg_len, uint8_t* key, uint8_t* iv, uint8_t* msg_cipher)
{
  vaes128cbc_err_t err = VAES128CBC_OK;
  int merr = 0;

  mbedtls_aes_context aes_ctx;

  merr = mbedtls_aes_setkey_enc(&aes_ctx, key, 128);
  if (!merr)
  merr = mbedtls_aes_crypt_cbc(&aes_ctx, MBEDTLS_AES_ENCRYPT, msg_len, iv, (uint8_t*)msg, msg_cipher);

  mbedtls_aes_free(&aes_ctx);

  if (merr) err = VAES128CBC_ERR_ENCRYPT_FAIL;

  return err;
}

static vaes128cbc_err_t _aes128cbc_dec(uint8_t* cipher, size_t cipher_len, uint8_t* key, uint8_t* iv, uint8_t* msg)
{
  vaes128cbc_err_t err = VAES128CBC_OK;
  int merr = 0;

  mbedtls_aes_context aes_ctx;

  merr = mbedtls_aes_setkey_dec(&aes_ctx, key, 128);
  if (!merr)
  merr = mbedtls_aes_crypt_cbc(&aes_ctx, MBEDTLS_AES_DECRYPT, cipher_len, iv, cipher, (uint8_t*)msg);

  mbedtls_aes_free(&aes_ctx);

  if (merr) err = VAES128CBC_ERR_DECRYPT_FAIL;

  return err;
}

/**
 * @brief Create key structure to be used on vaes128 encryption
 * @param siv Static part of IV key
 * @param siv_len Length of siv in bytes (0-16).
 *                Random bytes will be prepended if less than 16.
 * @param smsgk Static part of message key
 * @param smsgk_len Length of smsgk in bytes (0-16).
 *                  Random bytes will be prepended if less than 16.
 * @return Created key structure
 */
vaes128cbc_skeys_t vaes128cbc_setkeys(uint8_t* siv, uint8_t siv_len, uint8_t* smsgk, uint8_t smsgk_len)
{
  if (siv_len > VAES128_BLOCKSZ) siv_len = VAES128_BLOCKSZ;
  if (smsgk_len > VAES128_BLOCKSZ) smsgk_len = VAES128_BLOCKSZ;

  vaes128cbc_skeys_t vaesk;
  memset(&vaesk, 0, sizeof(vaesk));
  memcpy(vaesk.static_iv, siv, siv_len);
  memcpy(vaesk.static_msgk, smsgk, smsgk_len);
  vaesk.siv_len = siv_len;
  vaesk.smsgk_len = smsgk_len;

  return vaesk;
}

/**
 * @brief Encrypt a buffer using VAES128
 * @param vaesk Key structure to be used for encryption
 * @param buf Buffer to encrypt
 * @param len Length of buf in bytes
 * @param cipher [out] Encryption result buffer allocated on heap
 * @param cipher_len [out] Length of cipher in bytes
 * @return VAES128CBC_OK on successful encryption
 */
vaes128cbc_err_t vaes128cbc_enc(vaes128cbc_skeys_t vaesk, uint8_t* buf, size_t len, uint8_t** cipher, size_t* cipher_len)
{
  vaes128cbc_err_t err = VAES128CBC_OK;

  uint32_t msg_blocknum = len/VAES128_BLOCKSZ+1;
  uint8_t padding_num = msg_blocknum*VAES128_BLOCKSZ-len;
  size_t padded_buf_len = msg_blocknum*VAES128_BLOCKSZ;
  *cipher_len = padded_buf_len+(VAES128_BLOCKSZ-vaesk.siv_len)+(VAES128_BLOCKSZ-vaesk.smsgk_len);

  ESP_LOGD(TAG, "Encrypt sizes -> block_num: %u pad_num: %u msg: %u", msg_blocknum, padding_num, *cipher_len);

  // Generate randomized part of IV and MSGK and prepend it to the static part

  uint8_t iv[VAES128_BLOCKSZ];
  uint8_t riv_len = VAES128_BLOCKSZ-vaesk.siv_len;
  esp_fill_random(iv, riv_len);
  memcpy(&iv[riv_len], vaesk.static_iv, vaesk.siv_len);

  ESP_LOGD(TAG, "IV %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X"
              , iv[0], iv[1], iv[2], iv[3], iv[4], iv[5], iv[6], iv[7]
              , iv[8], iv[9], iv[10], iv[11], iv[12], iv[13], iv[14], iv[15]);

  uint8_t msgk[VAES128_BLOCKSZ];
  uint8_t rmsgk_len = VAES128_BLOCKSZ-vaesk.smsgk_len;
  esp_fill_random(msgk, rmsgk_len);
  memcpy(&msgk[rmsgk_len], vaesk.static_msgk, vaesk.smsgk_len);

  ESP_LOGD(TAG, "MSGK %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X"
              , msgk[0], msgk[1], msgk[2], msgk[3], msgk[4], msgk[5], msgk[6], msgk[7]
              , msgk[8], msgk[9], msgk[10], msgk[11], msgk[12], msgk[13], msgk[14], msgk[15]);

  // Pad the message
  uint8_t* padded_buf = malloc(padded_buf_len);
  memcpy(padded_buf, buf, len);
  uint8_t* padding_start = padded_buf+len;

  for (int i = 0; i < padding_num; i++)
  padding_start[i] = padding_num;

  // Encrypt the message then prepend the random part of IV and MSGK
  *cipher = malloc(*cipher_len);
  uint8_t iv_mod[VAES128_BLOCKSZ]; // Encryption fn modifies input IV so use this dupe as input IV
  memcpy(iv_mod, iv, VAES128_BLOCKSZ);
  err = _aes128cbc_enc(padded_buf, padded_buf_len, msgk, iv_mod, &(*cipher)[riv_len+rmsgk_len]);
  free(padded_buf);
  memcpy(*cipher, iv, riv_len);
  memcpy(&(*cipher)[riv_len], msgk, rmsgk_len);

  if (err) {
    free(*cipher);
    *cipher = NULL;
  }

  return err;
}

/**
 * @brief Encrypt a buffer using VAES128 and convert the result to hex string
 * @param vaesk Key structure to be used for encryption
 * @param buf Buffer to encrypt
 * @param len Length of buf in bytes
 * @param cipher_hstr [out] Encryption result hex string allocated on heap. Null-terminated.
 * @return VAES128CBC_OK on successful encryption
 */
vaes128cbc_err_t vaes128cbc_enc_hstr(vaes128cbc_skeys_t vaesk, uint8_t* buf, size_t len, char** cipher_hstr)
{
  vaes128cbc_err_t err = VAES128CBC_OK;

  uint8_t* cipher;
  size_t cipher_len;
  err = vaes128cbc_enc(vaesk, buf, len, &cipher, &cipher_len);
  if (!err) {
    *cipher_hstr = malloc(cipher_len*2+1);
    vaes128cbc_byte2hstr(cipher, cipher_len, *cipher_hstr);
    free(cipher);
  }

  return err;
}

/**
 * @brief Decrypt a buffer using VAES128
 * @param vaesk Key structure to be used for decryption
 * @param cipher Buffer to decrypt
 * @param cipher_len Length of buffer to decrypt
 * @param buf [out] Decryption result buffer allocated on heap
 * @param len [out] Length of buf in bytes. May be NULL if not needed.
 * @note Null-termination is always added to buf
 * @return VAES128CBC_OK on successful decryption
 */
vaes128cbc_err_t vaes128cbc_dec(vaes128cbc_skeys_t vaesk, uint8_t* cipher, size_t cipher_len, uint8_t** buf, size_t* len)
{
  vaes128cbc_err_t err = VAES128CBC_OK;

  uint8_t riv_len = VAES128_BLOCKSZ-vaesk.siv_len;
  uint8_t rmsgk_len = VAES128_BLOCKSZ-vaesk.smsgk_len;
  size_t padded_buf_len = cipher_len-riv_len-rmsgk_len;

  if (padded_buf_len % VAES128_BLOCKSZ != 0)
  err = VAES128CBC_ERR_WRONG_LEN;

  // Reconstruct complete IV and MSGK
  uint8_t iv[VAES128_BLOCKSZ];
  memcpy(iv, cipher, riv_len);
  memcpy(&iv[riv_len], vaesk.static_iv, vaesk.siv_len);

  ESP_LOGD(TAG, "IV %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X"
              , iv[0], iv[1], iv[2], iv[3], iv[4], iv[5], iv[6], iv[7]
              , iv[8], iv[9], iv[10], iv[11], iv[12], iv[13], iv[14], iv[15]);

  uint8_t msgk[VAES128_BLOCKSZ];
  memcpy(msgk, &cipher[riv_len], rmsgk_len);
  memcpy(&msgk[rmsgk_len], vaesk.static_msgk, vaesk.smsgk_len);

  ESP_LOGD(TAG, "MSGK %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X"
              , msgk[0], msgk[1], msgk[2], msgk[3], msgk[4], msgk[5], msgk[6], msgk[7]
              , msgk[8], msgk[9], msgk[10], msgk[11], msgk[12], msgk[13], msgk[14], msgk[15]);

  // Decrypt the message
  *buf = malloc(padded_buf_len);
  err = _aes128cbc_dec(&cipher[riv_len+rmsgk_len], padded_buf_len, msgk, iv, *buf);
  uint8_t* msg = *buf;

  // Remove padding
  if (!err) {
    uint8_t padding_num = msg[padded_buf_len-1];
    // Null terminate for convenience when message is known to be string
    msg[padded_buf_len-padding_num] = '\0';
    if (len != NULL)
    *len = padded_buf_len-padding_num;
  }
  else {
    free(buf);
    *buf = NULL;
    if (len != NULL) *len = 0;
  }

  return err;
}

/**
 * @brief Decrypt a hex string using VAES128
 * @param vaesk Key structure to be used for decryption
 * @param cipher_hstr Hex string to decrypt
 * @param chstr_len Length of cipher_hstr in bytes
 * @param buf [out] Decryption result buffer allocated on heap
 * @param len [out] Length of buf in bytes. May be NULL if not needed.
 * @note Null-termination is always added to buf
 * @return VAES128CBC_OK on successful decryption
 */
vaes128cbc_err_t vaes128cbc_dec_hstr(vaes128cbc_skeys_t vaesk, char* cipher_hstr, size_t chstr_len, uint8_t** buf, size_t* len)
{
  vaes128cbc_err_t err = VAES128CBC_OK;

  uint8_t* cipher = malloc(chstr_len/2+1);
  err = vaes128cbc_hstr2byte(cipher_hstr, chstr_len, cipher);

  if (!err) err = vaes128cbc_dec(vaesk, cipher, chstr_len/2, buf, len);
  free(cipher);

  return err;
}